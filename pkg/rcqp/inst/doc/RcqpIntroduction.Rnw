\documentclass{article}
\SweaveOpts{engine=R,eps=FALSE,pdf=TRUE,width=5,height=3,strip.white=TRUE,keep.source=TRUE}
%\VignetteIndexEntry{Introduction to rcqp}
\usepackage{lmodern}

\title{Introduction to the rcqp package}

\author{Bernard Desgraupes and Sylvain Loiseau\\<bernard.desgraupes@u-paris10.fr>, <sylvain.loiseau@univ-paris13.fr>}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
The \texttt{rcqp} R library is a wrapper onto the CWB software.
The CWB software, used in the field of corpus linguistics,
allows for indexing and querying large annotated corpora. The \texttt{rcqp}
library include CWB (as a shared library) and allows using R for running
cwb and import cwb output into statistical analyses.
\end{abstract}

\tableofcontents

\section{Introduction}
\label{sec:Intro}

The CWB (Corpus Workbench) software\footnote{http://cwb.sourceforge.net/} is a
set of tools for corpus linguistics, providing a powerful indexation and query
engine for annotated copora. An interactive command line program called CQP
(corpus query processor) is provided, as well as a client/server 
architecture.

CWB offers access to corpora through manipulation of vectors of positions
(offsets of the adressed / requested word(s) in the corpus) which can be turned
into the corresponding word forms, lemmas, or parts of speech if the corpus
provide these pieces of information.

In \textbf{rcqp}, CWB is turned into a shared library. As a result:

\begin{itemize}
\item the CWB data structures are mainly vectors, which are very convenient to manipulate in R;
\item R vector are wrapper onto the inner CWB C arrays, allowing for 
efficient access;
\item rcqp provide an easy way to run and query CWB, without having to separatly compile and
install CWB;
\item rcqp allows for analyzing the complex CWB data with R statistical capacities.
\end{itemize}

In \textbf{rcqp}, two different ways of calling CWB are provided:

\begin{itemize}
\item You can call CWB through the \textbf{cqi\_*} set of functions. These 
functions implement an interface defined by CWB (CQi). 
\item You can use a set of functions trying to help producing 
quantitative structures (frequency list, cross-tabulated frequency table) 
for statistical analyses of CWB corpora with R.
\end{itemize}

% ----------------------------------------------------------------
% ----------------------------------------------------------------


\section{The CQi set of functions}
\label{sec:cqi}

\subsection{CWB data-model}

Detailled information about the data model used into CWB is available in
\textit{CQP Query Language Tutorial}, Stefan Evert \& The OCWB 
Development Team, 17 February 2010.

In the short presentation below, the conventions used in \texttt{cqi\_*} function
names are in bold.

The fundamental information is the position, or rank, of each token: each token
have a position, 0-based, called \textbf{cpos}.

A corpus may be represented as an array where each line represent a token 
and each column represent an \textbf{attribute}.
Here are the first 20 lines of such an array representing the DICKENS demo 
corpus, with 38 columns.

<<cqi_corpus_representation, echo=FALSE>>=
library(rcqp)
c <- corpus("DICKENS")
c
@

The first 34 columns represent "\textbf{structural attribute}": this type of 
attribute define spans of tokens (like XML tag surrounding tokens), called \textbf{regions}.
A region is made of the tokens sharing a same value for this attribute.
A region is always made of consecutive tokens.
Thus, while the id is the same in a column, the corresponding tokens belong to the same region.
The id identifying a region is called \textbf{struc}.
Since regions are defined thanks to a struc value on tokens, there is no 
recursivity.
Tokens between two regions in a given structural attributes have a value of "-1".

They are, then, several columns containing string. They are the 
"\textbf{positional attribute}", giving for each word information such as lemma,
word-form, pos,... Each positional attribute has a list of \textbf{id}s, a 
numerical code for the different possible string forms.

Moreover, certains structural attribute have a string value associated 
with each struc (region). While each struc is unique to a region, string 
values can be repeated on several regions. For instance, the np\_h structural
 attribute, giving the head of the noun phrase, hold a string value.

In short, in CQi function names, the following convention are used:

\begin{description}
\item [cpos] a position, or rank, identifying a unique token in the corpus
\item [id] an id for a form (type) in the lexicon of a positional attribute 
lexicon.
\item [str] the string corresponding to an id in the lexicon of a positional 
attribute lexicon 
\item [struc] the id of a region in a given structural attribute 
\end{description}

A subcorpus is created thanks to the \textbf{cqi\_query} function. See 
\textit{CQP Query Language Tutorial}, Stefan Evert \& The OCWB 
Development Team, 17 February 2010, for a definition of the CQP query 
language.

A subcorpus is a collection of sequence of tokens matched by the query and
identified by their cpos. Since a query may match a sequence of tokens, a
subcorpus is a collection of (match, matchend) pairs, where \textbf{match}
is the cpos of 
the first token and \textbf{matchend} the cpos of the last token in the
sequence matched.
When only one token is addressed by a query, matchend is identical to match.
\textbf{match}, \textbf{matchend} (together with two other optionnal pieces of 
information: \textbf{target} and \textbf{keyword}) are the
\textbf{anchor}s (or sometime \textbf{field}: see cqi\_fdist1 et 2) 
available on each hit.

All index are 0-based in CWB: the cpos of the first token is 0, the first 
id for an positional attribute or the first struc for a structural 
attribute is 0, etc.

\subsection{A sample session}

<<cqi_session, echo=TRUE>>=
corpora <- cqi_list_corpora()
corpora[1:5]

# create the subcorpus "Interesting" (create the subcorpus internaliy
# with the given name but does not return any result).
cqi_query("DICKENS", "Interesting", '"interesting"');

# in the CQi API, the qualified name of subcorpus is corpus:subcorpus:
nbr_hit <- cqi_subcorpus_size("DICKENS:Interesting");
nbr_hit

### TODO : zero-based?
# A matrix: one line by hit, four columns: match, matchend, target, keyword.
dump <- cqi_dump_subcorpus("DICKENS:Interesting",1,20)
dump[1:10,]

# get the lemma of the "match" slot of each hit:
# Word's attributes (such as "lemma", "word", "pos") are always accessed 
# through qualified name : "corpus.attribute"
lemma <- cqi_cpos2str("DICKENS.lemma", dump[,1])
lemma[1:10]

# You can acheave the same result in one more steps, using id as an 
# intermediate step: 
ids <- cqi_cpos2id("DICKENS.lemma", dump[,1]);
lemma <- cqi_id2str("DICKENS.lemma", ids);
lemma[1:10]

# cqi_fdist1 create a frequency list according to one field (match, 
# matchend...) in a query; cqi_fdist2 a cross tabulated 
# frequency table according to two fields in a query

flist <- cqi_fdist1("DICKENS:Interesting", "match", "word")
flist

# cqi_fdist1 et cqi_fdist2 return numeric matrix : (lemma) id -> freq.
# use id2str in order to turn the (word) id into its form. 
data.frame(cqi_id2str("DICKENS.word", flist[,1]), flist[,2])

@

\subsection{Functions}
\label{sec:cqi-functions}

For more information about the actual use of these functions, see their help 
page.

All functions are prefixed with \textbf{cqi\_}.

\paragraph{cqi\_list\_corpora}

List all the corpora available in the registry.

<<list_corpora, echo=TRUE>>=
corpora <- cqi_list_corpora()
corpora[1:5]
@

\paragraph{cqi\_full\_name}

Give the full name of a corpus

\paragraph{cqi\_corpus\_info}

Various information about a corpus

\paragraph{cqi\_query}

Create a subcorpus. A subcorpus is a list of hit. 
Each hit contains four \textbf{field} : textbf{match} (the cpos of the first token of the 
matched sequence), textbf{matchend} (the cpos of the last token of the matched 
sequence, identical with match if the sequence is one token length), and 
two optionnal values (see CQP documentation), textbf{target} and 
textbf{keyword}.

<<cqi_query, echo=TRUE>>=
corpora <- cqi_list_corpora()
cqi_query("DICKENS", "Subcorpus", '"interesting"');
@

The \texttt{cqi\_query} does not return any value; it create the 
subcorpus as an object internally. See \texttt{cqi\_dump\_subcorpus} 
for retrieving the subcorpus. The subcorpus name must begin with a capital letter.

\paragraph{cqi\_list\_subcorpora}

List created subcorpora.

\paragraph{cqi\_drop\_subcorpus}

Delete a subcorpus.

\paragraph{cqi\_dump\_subcorpus}

Retrieve the subcorpus created by a \texttt{cqi\_query} function as a 
four-column matrix: one row by hit, and one column for each of the four 
\textbf{field}s stored for each hit (see \texttt{cqi\_query}).

<<dump_subcorpus, echo=TRUE>>=
cqi_query("DICKENS", "Subcorpus", '"interesting"');
x <- cqi_dump_subcorpus("DICKENS:Subcorpus");
x[1:10,];
@

\paragraph{cqi\_subcorpus\_size}

The number of hit in the subcorpus. This is identical with the number 
of row returned by \texttt{cqi\_dump\_subcorpus}.

\paragraph{cqi\_attributes}

Get the list of attributes (positional, structural, or aligned) in a 
corpus.

<<cqi_attributes, echo=TRUE>>=
positional_attributes <- cqi_attributes("DICKENS", "p");
positional_attributes
structural_attributes <- cqi_attributes("DICKENS", "s");
structural_attributes
@

\paragraph{cqi\_lexicon\_size}

Number of forms in a positional attribute. Attributes are 
denoted using their "qualified name", i.e. corpus:attribute:

<<lexicon_size, echo=TRUE>>=
lexicon_size <- cqi_lexicon_size("DICKENS:word");
lexicon_size
@

The greatest id of an attribute is lexicon\_size $ - 1 $.

\paragraph{cqi\_structural\_attribute\_has\_values}

Ask if a structural attribute has a string value associated with its 
region. For retreiving the actual string value associated with a region id 
(a struc), see \texttt{cqi\_struc2str}.

<<structural_attributes_has_values, echo=TRUE>>=
has_values <- cqi_structural_attribute_has_values("DICKENS.np_h");
has_values
@

\paragraph{cqi\_attribute\_size}

indicates number of actual elements (number of occurrences).

\begin{itemize}
\item on a positionnal attribute, it gives the number of tokens.
\item on a structural attribute, it gives the number of regions.
\item on an alignment attribute, it gives the number of aligned pairs.
\end{itemize}

\paragraph{cqi\_cpos2id}

From token cpos to the corresponding id in a given positional attribute.

<<cpos2id, echo=TRUE>>=
id <- cqi_cpos2id("DICKENS.word", 0:20);
id
@

\paragraph{cqi\_str2id}

Get the id corresponding to the given string in the lexicon of a given positional attribute.

<<str2id, echo=TRUE>>=
id <- cqi_str2id("DICKENS.word", "interesting");
id
@

\paragraph{cqi\_id2cpos}

All the tokens (cpos) having the given id of a given positional attribute.

<<id2cpos, echo=TRUE>>=
id <- cqi_str2id("DICKENS.word", "interesting");
cpos <- cqi_id2cpos("DICKENS.word", id);
cpos[1:10]
length(cpos);
@

\paragraph{cqi\_id2freq}

The number of tokens having the given id of a given positional attribute.

<<id2freq, echo=TRUE>>=
id <- cqi_str2id("DICKENS.word", "interesting");
freq <- cqi_id2freq("DICKENS.word", id);
freq
@

\paragraph{cqi\_id2str}

The string corresponding to a given id of a given positional attribute.

<<id2str, echo=TRUE>>=
id <- cqi_str2id("DICKENS.word", "interesting");
str <- cqi_id2str("DICKENS.word", id);
str
@

\paragraph{cqi\_cpos2str}

The string of a given positional attribute corresponding to a given id. 
This is identical to using cqi\_cpos2id then cqi\_id2str.

<<cpos2str, echo=TRUE>>=
str <- cqi_cpos2str("DICKENS.word", 1:10);
str
@

\paragraph{cqi\_regex2id}

Get the id corresponding to string of a positional attribute matched by a 
given regex.

<<regex2id, echo=TRUE>>=
id <- cqi_regex2id("DICKENS.word", '"Interest.*"');
id
@

\paragraph{cqi\_cpos2struc}

Get the region id (the struc, of a given structural attribute) to which 
belong a given token. Below, we are in the sentence with struc 53, then 54.

<<cpos2struc, echo=TRUE>>=
struc <- cqi_cpos2struc("DICKENS.s", 1010:1020);
struc
@

If the token is outside any region in the given structural attribute, -1 
is returned.

<<cpos2struc, echo=TRUE>>=
# In this sequence, tokens are not in nominal phrases.
cqi_cpos2struc("DICKENS.np", 1000:1010)
@

\paragraph{cqi\_struc2cpos}

Get the first and last cpos (tokens) belonging to a struc (a region id) of a given 
structural attribute. The second argument is vector of length 1, the 
returned value a vector of length 2.

<<struc2cpos, echo=TRUE>>=
cpos <- cqi_struc2cpos("DICKENS.np_h", 10);
cpos
@

\paragraph{cqi\_struc2str}

Get the string mapped to a region id (a struc) of a given structural 
attribute; available only or structural attribute having values.

<<struc2str, echo=TRUE>>=
str <- cqi_struc2str("DICKENS.np_h", 10);
str
@

\paragraph{cqi\_cpos2lbound}

Given a token, give the left-most token bellonging to the same 
region in the given structural attribute.

This is implemented as a simple shortcut for functions \texttt{cqi\_cpos2struc} and
\texttt{cqi\_struc2cpos[1]}.

<<cpos2lbound, echo=TRUE>>=
str <- cqi_cpos2lbound("DICKENS.np_h", 10);
str
@

\paragraph{cqi\_cpos2rbound}

Given a token, give the right-most token belonging to the same 
region in the given structural attribute.

This is implemented as a simple shortcut for functions \texttt{cqi\_cpos2struc} and 
\texttt{cqi\_struc2cpos(...)[2]}.

<<cpos2rbound, echo=TRUE>>=
str <- cqi_cpos2rbound("DICKENS.np_h", 10);
str
@

\paragraph{cqi\_alg2cpos}

From an id denoting a region of an alignment attribute to cpos of tokens contained into this 
region into the aligned corpora.

Suppose the two corpora \textbf{VIE\_FR} and \textbf{VIE\_RU} have 
been encoded using \textbf{tu\_id} as the 
attribute containing aligned chunk of text. The alignment attribute 
is \textbf{vie\_fr} in the corpus \textbf{VIE\_RU} and \textbf{vie\_ru} 
in the corpus \textbf{VIE\_FR}.

For the region 5 of \textbf{tu\_id} attribute in \textbf{VIE\_RU}, the 
corresponding cpos in corpus \textbf{VIE\_RU} are fetched with:

\begin{verbatim}
> cpos <- cqi_alg2cpos("VIE_RU.vie_fr", 5)
> cpos
[1]  89 132 110 166
> str <- cqi_cpos2str("VIE_FR.word", cpos)
[1] "comme"  "dont"   "Jeanne" "."
\end{verbatim}

\paragraph{cqi\_cpos2alg}

From token in corpus A to the corresponding region of an alignment 
attribute in an aligned corpus B.

\paragraph{cqi\_fdist1}

Get a frequency list of the strings of a given positionnal attribute in a 
subcorpus.

In the following example, all part-of-speech tag 

<<fdist1, echo=TRUE>>=
cqi_query("DICKENS", "Noun", '[pos="N.*"]')
fdist <- cqi_fdist1("DICKENS:Noun", "match", "pos")
cqi_id2str("DICKENS.pos", fdist[,1])
fdist[,2]
@

\paragraph{cqi\_fdist2}

Get a cross-tabulated table of the strings of a given positionnal 
attribute in a subcorpus * strings of a given.

% ----------------------------------------------------------------
% ----------------------------------------------------------------

\section{Integrating CQP into R S3 objects and quantitative structures}

A set of high-level functions is aimed at making more easy the use of cqp 
with R and more self-expanatory the data model of CWB. It provides in 
particular functions for creating easily quantitative data structures.

\subsection{A sample session}
\label{sec:rcqp-session}

<<rcqp_session, echo=TRUE>>=
# create a corpus
c <- corpus("DICKENS")
# summary give a quick view of the information available in the corpus,
# it does not display actual information:
summary(c)
#
# printing the corpus (by default, first tokens only)
c
@

\subsection{Functions}

\label{sec:rcqp-functions}

\subsubsection{Creating a corpus}

The first step in any sequence of this set of functions is creating a 
corpus. A corpus is created with the function \texttt{corpus()}.
This object may be used with the two functions below, as well as for creating 
subcorpus, flist and ftable objects (see bellow).

\paragraph{print}

Print all information (but the value of structural attribute having a 
value) as a data.frame.

\paragraph{summary}

Give the number of tokens of a corpus, list all the attributes 
(positionnal, structural, alignment) ; for each positional attribute (and 
structural attribute having a value) give the number of types and print 
some types.

\paragraph{write}

Write into a file with an argument "filename" and options arguments "from" 
and "to" denoting token cpos.

\paragraph{region\_sizes.cqp\_corpus}

Create a variable containing the size (in tokens) of a given structural 
attribute.

<<region_size_session, fig=TRUE, echo=TRUE>>=
c <- corpus("DICKENS");
sentences <- region_sizes.cqp_corpus(c, "s");
hist(sentences);
@

% ======================================================

\subsubsection{Creating a subcorpus: the function \textt{subcorpus}}

An object \texttt{subcorpus}
is created with the function \texttt{subcorpus()}. In the CWB 
terminology, a subcorpus is the set of the sequences matched by a query.

<<subcorpus_session, echo=TRUE>>=
c <- corpus("DICKENS");
sc <- subcorpus(c, '"interesting" "to" @ []');
sc
#
# if you want to change the lines printed (0-based):
print(sc, from=2, to=5);
#
# if you want more access on the kwic presentation
# (sorting, printing), you can construct a kwic object):
k <- kwic(sc, sort.anchor="target", sort.anchor.attribute="pos")
print(k, from=5, to=10, left.char=40, right.char=25)
@

\paragraph{print}

Print a KWIC (key-word in context) form.

\paragraph{summary}

Get a kwic summary of the size and content of the subcorpus.

\subsubsection{Creating frequency list: the \texttt{flist} function}

A frequency list may be created either with a corpus or with a subcorpus.

<<flist_session, echo=TRUE>>=

c <- corpus("DICKENS");
fl <- flist(c, "word");
summary(fl);
#
# get only the 1% most frequent forms
fl <- flist(c, "word", cutoff=0.01);
summary(fl);
fl[1:30]
#
# get only the forms with freq > 100
fl <- flist(c, "word", cutoff=100);
summary(fl);
fl[1:30]
@

With a subcorpus, a lot of options are available in order to construct the 
frequency list with a particular anchor, an offset for address tokens 
before or after this anchor, and left and right context in order to 
include tokens in a span.

<<flist_session2, echo=TRUE>>=
c <- corpus("DICKENS");
sc <- subcorpus(c, '"interesting" "to" @ []');
#
# Create a flist with the target anchor
fl <- flist(sc, "target", "word");
summary(fl);
#
fl <- flist(sc, "target", "pos");
fl;
#
# or with the match..matchend span, extended to -5 .. +5 tokens :
fl <- flist(sc, c("match", "matchend"), "word", left.context=5, right.context=5);
summary(fl);
fl[1:10]
@

\paragraph{summary.cqp\_flist}

Print information about the frequency list.

\subsubsection{Create a frequency table: the \texttt{ftable} function}

\texttt{ftable} create a frequency table: a cross-tabulated
frequency count according to two attributes.
\texttt{ftable} is applied either on a corpus or a subcorpus.
It produces a data.frame.

\paragraph{ftable with corpus}

\texttt{ftable} allows for creating frequency tables using a 
corpus object. The cross-tabulated fields may be positional or  
structural attributes.

<<ftable_session1, fig=TRUE, echo=TRUE>>=
library(reshape);
c <- corpus("DICKENS");
f <- ftable(c, "novel_title", "pos");
f[1:10,]
#
# create a contingency table
t <- cast(f, attribute1 ~ attribute2, value="freq", fun.aggregate=sum )
#
# Visual inspection of frequency of various POS in the different novels
mosaicplot(as.matrix(t));
@

Positional attributes (and structural attributes having values) are 
represented with their string representations rather than with ids. For 
positional attributes, it is only a matter of presentation, since each 
ids has it own string; but for structural attributes having values,
it may entails different counting: occurrence of phenomena belonging to
different struc but with same value are then counted together.
You can force the use of ids rather than string/value with the 
\texttt{attribute1.use.id} and \texttt{attribute2.use.id} options.

Counts are made on token basis, i.e. each token of the corpus is an 
individual on which the two modalities (attributes) are considered. If you 
use two structural attributes as argument in \texttt{ftable},
and one of them does not have values the third column count the number of 
tokens in the smallest region. In the following example, each line give
the length (in number of tokens, third column) of each sentence (second column)
in each novel, represented by its title:

<<ftable_session2, echo=TRUE>>=
f <- ftable(c, "novel_title", "s")
f[1:10,]
@

If both structural attributes have values, you may want to count the of 
times the modalities are co-occurring, rather than the total number of 
tokens included in these cooccurrences. Fot that purpose you can use the
\texttt{structural.attribute.unique.id=TRUE} option. In the following 
example, we count the number of time each head appears in each novel :

<<ftable_session3, echo=TRUE>>=
f <- ftable(c, "novel_title", "pp_h", structural.attribute.unique.id=TRUE)
f[1:10,]
@

Here on the contrary, we count the total number of tokens in each 
prepositional phrases having a given head :

<<ftable_session4, echo=TRUE>>=
f <- ftable(c, "novel_title", "pp_h")
f[1:10,]
@

\paragraph{ftable with subcorpus}

Applied on subcorpus, the \texttt{ftable} function is mainly a wrapper on the 
\texttt{cqi\_fdist2} function. However, it retuns a three columns data.frame
with <strings>, <string>, <freq> rather than a three columns matrix with 
<ids>, <ids>, <freq> like \texttt{cqi\_fdist2}.

<<ftable_session5, echo=TRUE>>=
c <- corpus("DICKENS");
sc <- subcorpus(c, '"from" @ [] "to" []')
f <- ftable(sc, "target", "word", "matchend", "word");
f[1:10,]
@

% ----------------------------------------------------------------
% ----------------------------------------------------------------

% \begin{Schunk}
% \begin{Sinput}
% 
% \end{Sinput}
% \end{Schunk}

\end{document}


