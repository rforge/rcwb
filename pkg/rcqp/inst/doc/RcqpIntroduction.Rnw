\documentclass{article}
\SweaveOpts{engine=R,eps=FALSE,pdf=TRUE,width=5,height=3,strip.white=true,keep.source=TRUE}
%\VignetteIndexEntry{Introduction to rcqp}
\usepackage{lmodern}

\title{Introduction to the rcqp package}

\author{Bernard Desgraupes and Sylvain Loiseau\\<bernard.desgraupes@u-paris10.fr>, <sylvain.loiseau@univ-paris13.fr>}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
The \texttt{rcqp} R library is a wrapper on the CWB software.
The CWB software, used in the field of corpus linguistics,
lets index and query large annotated corpora. The \texttt{rcqp}
library includes the CWB code and allows using R to execute
CWB functions and import their output into statistical analyses.
\end{abstract}

\vspace{5mm}
\hrule
\tableofcontents
\vspace{5mm}
\hrule

\newpage

\section{Introduction}
\label{sec:Intro}

The CWB (Corpus Workbench) software\footnote{http://cwb.sourceforge.net/} is a
set of tools for corpus linguistics, providing a powerful indexation and query
engine for annotated corpora. An interactive command line program called CQP
(\emph{corpus query processor}) is provided, as well as a client/server 
architecture.

CWB offers access to corpora through manipulation of vectors of positions
(offsets of the adressed / requested word(s) in the corpus) which can be turned
into the corresponding word forms, lemmas, or parts of speech if the corpus
provides these pieces of information.

In \textbf{rcqp}, CWB is turned into an R library. As a result:

\begin{itemize}
\item the CWB data structures are mainly vectors, which are very convenient to manipulate in R;
\item R vectors are wrappers on the inner CWB C arrays, thus providing
efficient access;
\item \texttt{rcqp} provides an easy way to run and query CWB, without having 
to separately compile and
install the CWB software;
\item \texttt{rcqp} lets you take advantage of the R statistical capacities for analyzing the complex CWB data.
\end{itemize}

In \textbf{rcqp}, two different ways of calling CWB are provided:

\begin{itemize}
\item You can call CWB through the \textbf{cqi\_*} set of functions. These 
functions implement an interface defined by CWB (CQi). 
\item You can use a set of functions trying to help producing 
quantitative structures (frequency lists, cross-tabulated frequency 
tables) for statistical analyses of CWB corpora with R.
\end{itemize}

% ----------------------------------------------------------------
% ----------------------------------------------------------------


\section{The CQi set of functions}
\label{sec:cqi}

\subsection{CWB data-model}

Detailled information about the data model used into CWB is available in
\textit{CQP Query Language Tutorial}, Stefan Evert \& The OCWB 
Development Team, 17 February 2010.

In the short presentation below, the conventions used in \texttt{cqi\_*} function
names are in boldface.

The fundamental information is the position, or rank, of each token: each token
has a position, 0-based, called \textbf{cpos}.

A corpus may be represented as an array where each line represents a token 
and each column represents an \textbf{attribute}.
Here are the first 20 lines of such an array, representing the DICKENS demo 
corpus, with 38 columns.

<<cqi_corpus_representation, echo=FALSE>>=
library(rcqp)
c <- corpus("DICKENS")
c
@

The first 34 columns represent \textbf{structural attributes}: this 
kind of 
attribute defines spans of tokens (like XML tags surrounding tokens), called \textbf{regions}.
A region is made of the tokens sharing a same value for this attribute.
A region is always made of consecutive tokens.
Thus, while the id is the same in a column, the corresponding tokens belong to the same region.
The id identifying a region is called a \textbf{struc}.
Since regions are defined thanks to a struc value on tokens, there is no 
recursivity.
Tokens between two regions, with respect to a given structural 
attribute, have a value of $-1$.

Next there are several columns containing strings. They are the 
\textbf{positional attributes}, giving for each word information such as lemma,
word-form, pos,... Each positional attribute has a list of 
\textbf{id}s, which are  unique
numerical codes for the different possible string forms.

Moreover, certain structural attributes have a string value associated 
with each \emph{struc} (region). While each struc is unique to a region, string 
values can be repeated over several regions. For instance, the np\_h structural
 attribute, giving the head of the noun phrase, holds a string value.

In short, in CQi function names, the following types of data are used:
\begin{description}
\item [cpos] a position, or rank, identifying a unique token in the 
corpus;
\item [id] an id for a form (type) in the lexicon of a positional attribute 
lexicon;
\item [str] the string corresponding to an id in the lexicon of a positional 
attribute lexicon;
\item [struc] the id of a region in a given structural attribute .
\end{description}

A subcorpus is created thanks to the \textbf{cqi\_query} function. See 
\textit{CQP Query Language Tutorial}, Stefan Evert \& The OCWB 
Development Team, 17 February 2010, for a complete specification of the CQP query 
language.

A subcorpus is a collection of sequences of tokens matched by a query and
identified by their \emph{cpos}. Since a query may match a sequence of tokens, a
subcorpus is a collection of \emph{(match, matchend)} pairs, where \textbf{match}
is the cpos of 
the first token and \textbf{matchend} the cpos of the last token in the
sequence matched.
When only one token is addressed by a query, matchend is identical to match.

The \textbf{match} and \textbf{matchend} positions (together with two other optional pieces of 
information named \textbf{target} and \textbf{keyword}) are referred to as the
\textbf{anchor}s (or sometime \textbf{field}s: see cqi\_fdist1 et cqi\_fdist2) 
available on each hit.

All indices are 0-based in CWB: the cpos of the first token is 0, the first 
id for an positional attribute or the first struc for a structural 
attribute is 0, etc.


\subsection{A sample session}

<<cqi_session, echo=TRUE>>=
corpora <- cqi_list_corpora()
corpora[1:5]

# create the subcorpus "Interesting" (create the subcorpus internaliy
# with the given name but does not return any result).
cqi_query("DICKENS", "Interesting", '"interesting"');

# in the CQi API, the qualified name of subcorpus is corpus:subcorpus:
nbr_hit <- cqi_subcorpus_size("DICKENS:Interesting");
nbr_hit

### TODO : zero-based?
# A matrix: one line by hit, four columns: match, matchend, target, keyword.
dump <- cqi_dump_subcorpus("DICKENS:Interesting",1,20)
dump[1:10,]

# get the lemma of the "match" slot of each hit:
# Word's attributes (such as "lemma", "word", "pos") are always accessed 
# through qualified name : "corpus.attribute"
lemma <- cqi_cpos2str("DICKENS.lemma", dump[,1])
lemma[1:10]

# You can acheave the same result in one more steps, using id as an 
# intermediate step: 
ids <- cqi_cpos2id("DICKENS.lemma", dump[,1]);
lemma <- cqi_id2str("DICKENS.lemma", ids);
lemma[1:10]

# cqi_fdist1 create a frequency list according to one field (match, 
# matchend...) in a query; cqi_fdist2 a cross tabulated 
# frequency table according to two fields in a query

flist <- cqi_fdist1("DICKENS:Interesting", "match", "word")
flist

# cqi_fdist1 et cqi_fdist2 return numeric matrix : (lemma) id -> freq.
# use id2str in order to turn the (word) id into its form. 
data.frame(cqi_id2str("DICKENS.word", flist[,1]), flist[,2])

@

\subsection{Functions}
\label{sec:cqi-functions}

For more information about the actual use of these functions, see
their respective help pages.

All functions are prefixed with \textbf{cqi\_}.

\paragraph{cqi\_list\_corpora}

List all the corpora available in the registry.

<<list_corpora, echo=TRUE>>=
corpora <- cqi_list_corpora()
corpora[1:5]
@

\paragraph{cqi\_full\_name}

Return the full name of a corpus.

\paragraph{cqi\_corpus\_info}

Return various informations about a corpus.

\paragraph{cqi\_query}

Create a subcorpus. A subcorpus is a list of hits. 
Each hit contains four fields : textbf{match} (the cpos of the first token of the 
matched sequence), textbf{matchend} (the cpos of the last token of the matched 
sequence, identical with match if the sequence is one token long), and 
two optionnal values (see CQP documentation), textbf{target} and 
textbf{keyword}.

<<cqi_query, echo=TRUE>>=
corpora <- cqi_list_corpora()
cqi_query("DICKENS", "Subcorpus", '"interesting"');
@

The \texttt{cqi\_query} does not return any value; it creates the
subcorpus as an object internally. Use \texttt{cqi\_dump\_subcorpus}
for retrieving the subcorpus contents. The subcorpus name must begin
with a capital letter.

\paragraph{cqi\_list\_subcorpora}

List the created subcorpora.

\paragraph{cqi\_drop\_subcorpus}

Delete a subcorpus.

\paragraph{cqi\_dump\_subcorpus}

Retrieve the subcorpus created by a call to the \texttt{cqi\_query} function as a 
four-column matrix: one row by hit, and one column for each of the four 
fields (see \texttt{cqi\_query}).

<<dump_subcorpus, echo=TRUE>>=
cqi_query("DICKENS", "Subcorpus", '"interesting"');
x <- cqi_dump_subcorpus("DICKENS:Subcorpus");
x[1:10,];
@

\paragraph{cqi\_subcorpus\_size}

Return the number of hits in a subcorpus. This is the same as the number 
of rows returned by \texttt{cqi\_dump\_subcorpus}.

\paragraph{cqi\_attributes}

Get the list of attributes (positional, structural, or aligned) in a 
corpus.

<<cqi_attributes, echo=TRUE>>=
positional_attributes <- cqi_attributes("DICKENS", "p");
positional_attributes
structural_attributes <- cqi_attributes("DICKENS", "s");
structural_attributes
@

\paragraph{cqi\_lexicon\_size}

Number of forms in a positional attribute. Attributes are 
denoted using their \emph{qualified name}, of the form 
\verb|corpus:attribute|.

<<lexicon_size, echo=TRUE>>=
lexicon_size <- cqi_lexicon_size("DICKENS:word");
lexicon_size
@

The greatest id of an attribute is lexicon\_size $ - 1 $.

\paragraph{cqi\_structural\_attribute\_has\_values}

Ask if a structural attribute has a string value associated with its 
region. For retrieving the actual string value associated with a region id 
(a struc), see \texttt{cqi\_struc2str}.

<<structural_attributes_has_values, echo=TRUE>>=
has_values <- cqi_structural_attribute_has_values("DICKENS.np_h");
has_values
@

\paragraph{cqi\_attribute\_size}

Return the number of actual elements (number of occurrences).

\begin{itemize}
\item on a positionnal attribute, it gives the number of tokens.
\item on a structural attribute, it gives the number of regions.
\item on an alignment attribute, it gives the number of aligned pairs.
\end{itemize}

\paragraph{cqi\_cpos2id}

Convert from a token cpos to the corresponding id in a given positional attribute.

<<cpos2id, echo=TRUE>>=
id <- cqi_cpos2id("DICKENS.word", 0:20);
id
@

\paragraph{cqi\_str2id}

Get the id corresponding to the specified string in the lexicon of a given positional attribute.

<<str2id, echo=TRUE>>=
id <- cqi_str2id("DICKENS.word", "interesting");
id
@

\paragraph{cqi\_id2cpos}

Return all the tokens (cpos) corresponding to the specified id of a 
certain positional attribute.

<<id2cpos, echo=TRUE>>=
id <- cqi_str2id("DICKENS.word", "interesting");
cpos <- cqi_id2cpos("DICKENS.word", id);
cpos[1:10]
length(cpos);
@

\paragraph{cqi\_id2freq}

Return the number of tokens corresponding to the specified id of a 
certain positional attribute.

<<id2freq, echo=TRUE>>=
id <- cqi_str2id("DICKENS.word", "interesting");
freq <- cqi_id2freq("DICKENS.word", id);
freq
@

\paragraph{cqi\_id2str}

Return the string corresponding to the specified id of a 
certain positional attribute.

<<id2str, echo=TRUE>>=
id <- cqi_str2id("DICKENS.word", "interesting");
str <- cqi_id2str("DICKENS.word", id);
str
@

\paragraph{cqi\_cpos2str}

Return the string of a given positional attribute corresponding to a given id. 
This is identical to using cqi\_cpos2id then cqi\_id2str.

<<cpos2str, echo=TRUE>>=
str <- cqi_cpos2str("DICKENS.word", 1:10);
str
@

\paragraph{cqi\_regex2id}

Get the id corresponding to the string of a positional attribute matched by a 
given regex.

<<regex2id, echo=TRUE>>=
id <- cqi_regex2id("DICKENS.word", '"Interest.*"');
id
@

\paragraph{cqi\_cpos2struc}

Get the region id (the struc, of a given structural attribute) to which 
a given token belongs. Below, we are in the sentence with struc 53, then 54.

<<cpos2struc, echo=TRUE>>=
struc <- cqi_cpos2struc("DICKENS.s", 1010:1020);
struc
@

If the token is outside any region in the given structural attribute, -1 
is returned.

<<cpos2struc, echo=TRUE>>=
# In this sequence, tokens are not in nominal phrases.
cqi_cpos2struc("DICKENS.np", 1000:1010)
@

\paragraph{cqi\_struc2cpos}

Get the first and last cpos (tokens) belonging to a struc (a region id) of a given 
structural attribute. The second argument is a vector of length 1, the 
returned value a vector of length 2.

<<struc2cpos, echo=TRUE>>=
cpos <- cqi_struc2cpos("DICKENS.np_h", 10);
cpos
@

\paragraph{cqi\_struc2str}

Get the string mapped to a region id (a struc) of a given structural 
attribute; available only for structural attributes having values.

<<struc2str, echo=TRUE>>=
str <- cqi_struc2str("DICKENS.np_h", 10);
str
@

\paragraph{cqi\_cpos2lbound}

Given a token, return the left-most token belonging to the same 
region in the given structural attribute.

This is implemented as a simple shortcut for functions \texttt{cqi\_cpos2struc} and
\texttt{cqi\_struc2cpos[1]}.

<<cpos2lbound, echo=TRUE>>=
str <- cqi_cpos2lbound("DICKENS.np_h", 10);
str
@

\paragraph{cqi\_cpos2rbound}

Given a token, return the right-most token belonging to the same 
region in the given structural attribute.

This is implemented as a simple shortcut for functions \texttt{cqi\_cpos2struc} and 
\texttt{cqi\_struc2cpos(...)[2]}.

<<cpos2rbound, echo=TRUE>>=
str <- cqi_cpos2rbound("DICKENS.np_h", 10);
str
@

\paragraph{cqi\_alg2cpos}

Convert from an id denoting a region of an alignment attribute to cpos of tokens contained into this 
region in the aligned corpora.

Suppose that two parallel corpora \textbf{VIE\_FR} and \textbf{VIE\_RU} have 
been encoded using \textbf{tu\_id} as the 
attribute containing aligned chunks of text. The alignment attribute 
is named \textbf{vie\_fr} in the corpus \textbf{VIE\_RU} and \textbf{vie\_ru} 
in the corpus \textbf{VIE\_FR}.

For region 5 of the \textbf{tu\_id} attribute in \textbf{VIE\_RU}, the 
corresponding cpos in corpus \textbf{VIE\_RU} are obtained with:

\begin{verbatim}
> cpos <- cqi_alg2cpos("VIE_RU.vie_fr", 5)
> cpos
[1]  89 132 110 166
> str <- cqi_cpos2str("VIE_FR.word", cpos)
[1] "comme"  "dont"   "Jeanne" "."
\end{verbatim}

\paragraph{cqi\_cpos2alg}

Convert from a token in corpus A to the corresponding region of an alignment 
attribute in an aligned corpus B.

\paragraph{cqi\_fdist1}

Get a frequency list of the strings of a given positionnal attribute in a 
subcorpus.

In the following example, get all part-of-speech tags :

<<fdist1, echo=TRUE>>=
cqi_query("DICKENS", "Noun", '[pos="N.*"]')
fdist <- cqi_fdist1("DICKENS:Noun", "match", "pos")
cqi_id2str("DICKENS.pos", fdist[,1])
fdist[,2]
@

\paragraph{cqi\_fdist2}

Get a cross-tabulated table of the strings of a given positionnal 
attribute in a subcorpus * strings of a given.

% ----------------------------------------------------------------
% ----------------------------------------------------------------

\section{Integrating CQP into R S3 objects and quantitative structures}

A set of high-level functions is aimed at making easier the use of cqp 
with R and more self-explanatory the data model of CWB. It provides in 
particular functions for easily creating quantitative data structures.

\subsection{A sample session}
\label{sec:rcqp-session}

<<rcqp_session, echo=TRUE>>=
# create a corpus
c <- corpus("DICKENS")
# summary give a quick view of the information available in the corpus,
# it does not display actual information:
summary(c)
#
# printing the corpus (by default, first tokens only)
c
@

\subsection{Functions}

\label{sec:rcqp-functions}

\subsubsection{Creating a corpus}

The first step in any sequence of this set of functions is creating a 
corpus object. A corpus object is created with the function \texttt{corpus()}.
This object may be used with the two functions below, as well as for creating 
subcorpus, flist and ftable objects (see below).

\paragraph{print}

Print all information (but the value of structural attributes having a 
value) as a dataframe.

\paragraph{summary}

Give the number of tokens of a corpus, list all the attributes 
(positionnal, structural, alignment) ; for each positional attribute (and 
structural attribute having a value) give the number of types and print 
some type samples.

\paragraph{write}

Write into a file with an argument \emph{filename} and optional arguments \emph{from} 
and \emph{to} denoting token cpos.

\paragraph{region\_sizes.cqp\_corpus}

Create a variable containing the size (in tokens) of a given structural 
attribute.

<<region_size_session, fig=TRUE, echo=TRUE>>=
c <- corpus("DICKENS");
sentences <- region_sizes(c, "s");
hist(sentences);
@

% ======================================================

\subsubsection{Creating a subcorpus: the function \texttt{subcorpus}}

An \texttt{subcorpus} object
is created with the function \texttt{subcorpus()}. In the CWB 
terminology, a subcorpus is the set of sequences matched by a query.

<<subcorpus_session, echo=TRUE>>=
c <- corpus("DICKENS");
sc <- subcorpus(c, '"interesting" "to" @ []');
sc
#
# if you want to change the lines printed (0-based):
print(sc, from=2, to=5);
#
# if you want more access on the kwic presentation
# (sorting, printing), you can construct a kwic object):
k <- kwic(sc, sort.anchor="target", sort.anchor.offset=0, sort.anchor.attribute="pos", right.context=10, left.context=10)
print(k, from=5, to=10, left.char=25, right.char=25)
@

\paragraph{print}

Print a KWIC (\emph{keyword in context}) form.

\paragraph{summary}

Get a kwic summary of the size and content of the subcorpus.

\subsubsection{Creating frequency lists: the \texttt{flist} function}

A frequency list may be created either with a corpus or with a subcorpus.

<<flist_session, echo=TRUE>>=

c <- corpus("DICKENS");
fl <- flist(c, "word");
summary(fl);
#
# get only the 1% most frequent forms
fl <- flist(c, "word", cutoff=0.01);
summary(fl);
fl[1:30]
#
# get only the forms with freq > 100
fl <- flist(c, "word", cutoff=100);
summary(fl);
fl[1:30]
@

With a subcorpus, a lot of options are available in order to construct the 
frequency list with a particular anchor, an offset for address tokens 
before or after this anchor, and left and right contexts in order to 
include tokens in a span.

<<flist_session2, echo=TRUE>>=
c <- corpus("DICKENS");
sc <- subcorpus(c, '"interesting" "to" @ []');
#
# Create a flist with the target anchor
fl <- flist(sc, "target", "word");
summary(fl);
#
fl <- flist(sc, "target", "pos");
fl;
#
# or with the match..matchend span, extended to -5 .. +5 tokens :
fl <- flist(sc, c("match", "matchend"), "word", left.context=5, right.context=5);
summary(fl);
fl[1:10]
@

\paragraph{summary.cqp\_flist}

Print information about the frequency list.

\subsubsection{Create a frequency table: the \texttt{ftable} function}

The \texttt{ftable} function creates a frequency table: a cross-tabulated
frequency count according to two attributes.
\texttt{ftable} may be applied either on a corpus, or a subcorpus.
It produces a dataframe.

\paragraph{ftable with corpus}

\texttt{ftable} lets create frequency tables using a 
corpus object. The cross-tabulated fields may be positional or  
structural attributes.

<<ftable_session1, fig=TRUE, echo=TRUE>>=
library(reshape);
c <- corpus("DICKENS");
f <- ftable(c, "novel_title", "pos");
f[1:10,]
#
# create a contingency table
t <- cast(f, novel_title ~ pos, value="freq", fun.aggregate=sum )
#
# Visual inspection of frequency of various POS in the different novels
mosaicplot(as.matrix(t));
@

Positional attributes (and structural attributes having values) are 
represented by their string values rather than by ids. For 
positional attributes, it is only a matter of presentation, since each 
id has its own string; but for structural attributes having values,
it may entail a different counting: occurrences of phenomena belonging to
different strucs but with same value are then counted together.
You can force the use of ids rather than string values with the 
\texttt{attribute1.use.id} and \texttt{attribute2.use.id} options.

Counts are made on token basis, i.e. each corpus token is an 
individual on which the two modalities (attributes) are considered. If you 
use two structural attributes as arguments in \texttt{ftable},
and one of them does not have values, then the third column counts the number of 
tokens in the smallest region. In the following example, each line 
gives the length (in number of tokens, third column) of each sentence (second column)
in each novel, represented by its title:

<<ftable_session2, echo=TRUE>>=
f <- ftable(c, "novel_title", "s")
f[1:10,]
@

If both structural attributes have values, you may want to count the 
number of 
times the modalities are cooccurring, rather than the total number of 
tokens included in these cooccurrences. For that purpose, you can use the
\texttt{structural.attribute.unique.id=TRUE} option. In the following 
example, we count the number of times each head appears in each novel :

<<ftable_session3, echo=TRUE>>=
f <- ftable(c, "novel_title", "pp_h", structural.attribute.unique.id=TRUE)
f[1:10,]
@

Here on the contrary, we count the total number of tokens in each 
prepositional phrase having a given head :

<<ftable_session4, echo=TRUE>>=
f <- ftable(c, "novel_title", "pp_h")
f[1:10,]
@

\paragraph{ftable with subcorpus}

Applied on a subcorpus, the \texttt{ftable} function is mainly a wrapper on the 
\texttt{cqi\_fdist2} function. However, it returns a three columns dataframe
with <strings>, <string>, <freq> rather than a three columns matrix with 
<ids>, <ids>, <freq> like \texttt{cqi\_fdist2}.

<<ftable_session5, echo=TRUE>>=
c <- corpus("DICKENS");
sc <- subcorpus(c, '"from" @ [] "to" []')
f <- ftable(sc, "target", "word", "matchend", "word");
f[1:10,]
@

% ----------------------------------------------------------------
% ----------------------------------------------------------------

% \begin{Schunk}
% \begin{Sinput}
% 
% \end{Sinput}
% \end{Schunk}

\end{document}


