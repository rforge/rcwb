\documentclass{article}
\SweaveOpts{engine=R,eps=FALSE,pdf=TRUE,width=5,height=3,strip.white=TRUE,keep.source=TRUE}
\title{Introduction to the rcqp package}
\author{Bernard Desgraupes and Sylvain Loiseau\\<bdesgraupes@orange.fr>, <sylvain.loiseau@univ-paris13.fr>}
\date{\today}
\begin{document}
\maketitle
\begin{abstract}

rcqp R library is a wrapper onto the CWB software. The CWB library, used in the field of corpus
linguistics, allows for indexing and querying large annotated corpora. The rcqp
library include CWB (as shared library) and allows using R for running
cwb and import cwb output into statistical analyses.

\end{abstract}

<<preliminaries, echo=FALSE>>=
options(width=75)
#Sys.setenv("CORPUS_REGISTRY"=system.file("extdata", "registry", package = "rcqp"))
@

\section{Introduction}
\label{sec:Intro}

The CWB (Corpus Workbench) software\footnote{http://cwb.sourceforge.net/} is a
set of tools for corpus linguistics, providing a powerful indexation and query
engine for annotated copora. An interactive command line program called CQP
(corpus query processor) is provided, as well as a client/server solution.

CWB offers access to corpora through manipulation of vectors of positions
(offsets of the adressed / requested word(s) in the corpus) which can be turned
into the corresponding word form, lemma, or part of speech if the corpus
provide these pieces of information.

In rcqp, CWB is turned into a shared library. As a result:
\begin{itemize}
\item the CWB data structures are mainly vectors, which are very convenient to manipulate in R;
\item R vector are wrapper onto the inner CWB C arrays, without conversion of socket communication;
\item rcqp provide an easy way to run and query CWB, without having to separatly compile and
install CWB;
\item rcqp allows for examinating the the complexe data accessed though CWB with the statistical power of R.
\end{itemize}

In rcqp, four different ways of calling CWB are provided:

\begin{itemize}
\item You can call CWB through the "cqi_\ast" set of functions. These 
functions implement an interface defined by CWB (CQi). 
\item You can use a set of more "high-level" functions for producing 
quantitative structures (frequency list, cross-tabulated frequency table), 
or kwic.
\item You can use a kind of interactive shell inside R, mimicking basic 
features of the "cqp" command line utilities.
\item At last, you can use a small GUI writen in tk for running query and 
displaying result as a kwic list.
\end{itemize}

% ----------------------------------------------------------------
% ----------------------------------------------------------------


\section{The CQi set of functions}
\label{sec:cqi}

All functions are prefixed with cqi_.

\subsection{A sample session}

<<cqi_session, echo=TRUE>>=

library(rcqp)

corpora <- cqi_list_corpora()
corpora

# create the subcorpus "Interesting" (does not return any result).
cqi_query("DICKENS", "Interesting", "[lemma=\"interesting\"]");

# in the CQi API, the qualified name of subcorpus is corpus:subcorpus:
nbr_hit <- cqi_subcorpus_size("DICKENS:Interesting");

# A matrix of cpos (token rank), one line by hit, four columns: match, matchend, target, keyword.
dump <- cqi_dump_subcorpus("DICKENS:Interesting",1,nbr_hit)
dump[1:10,]

# get the lemma of the "match" slot of each hit:
# Word's attributes (such as "lemma", "word", "pos") are always accessed 
# through qualified name : "corpus.attribute"
lemma <- cqi_cpos2str("DICKENS.lemma", dump[,1])

# You can acheave the same result in one more steps, using id as an 
# intermediate step: 
ids <- cqi_cpos2id("DICKENS.lemma", dump[,1]);
lemma <- cqi_id2str("DICKENS.lemma", ids);

# cqi_fdist1 create a frequency list according to one field (match, 
# matchend...) in a query; cqi_fdist2 a cross tabulated 
# frequency table according to two fields in a query

flist <- cqi_fdist1("DICKENS:Interesting", "match", "word")
flist

# cqi_fdist1 et cqi_fdist2 return numeric matrix : (lemma) id -> freq.
# use id2str in order to turn the (word) id into its form. 
data.frame(cqi_id2str("DICKENS.word", flist[,1]), flist[,2])

@

\label{sec:cqi-session}

\subsection{Data-model}

In order to get a picture of the data model used into CWB, see section 1.2 
of the \textit{CQP Query Language Tutorial}, Stefan Evert \& The OCWB 
Development Team, 17 February 2010.

A corpus is divided in position (rank), each token having a position. 
A corpus may be represented in an array. Here are the first 20 positions 
of the DICKENS demo corpus.

<<cqi_corpus_representation, echo=FALSE>>=
c <- corpus("DICKENS")
c
@

First, they are several columns corresponding to "structural attribute", 
i.e. span of tokens like XML tag surrounding tokens, called regions. Each 
region for each structural attribute as an id. While the id is the 
same in a column, the corresponding tokens belong to the same region. 
Tokens between two regions in a given structural attributes have a value of 
"-1".

They are, then, several columns containing string. They are the 
"positional attribute" of each word: lemma, word-form, pos, other 
information... Each positional attribute has his list of ids for coding 
each possible form.

Moreover, certains structural attribute have a string value associated 
with each id (region) (while each id is unique, string value can be repeated). For 
instance, the np_h structural attribute, giving the head of the noun 
phrase, hold a string value.

In CQi function names, the following convention are used:

\begin{itemize}
\item cpos : a position, or rank, identifying a unique token in the corpus
\item id : a form of a given positional attribute.
\item struc : a given region of a structural attribute 
\item str : the corresponding to a given id of a positional attribute or 
of a structural attribute having a value.
\end{itemize}

\subsection{Functions}
\label{sec:cqi-functions}

For more information about the actual use of this function, see their help 
page.

\paragraph{cqi_attribute_size}

indicates number of actual elements (number of occurrences).
\begin{itemize}
\item on a positionnal attribute, it gives the number of tokens.
\item on a structural attribute, it gives the number of regions.
\item on an alignment attribute, it gives the number of aligned pairs.
\end{itemize}

\paragraph{cqi\_attributes}

Get the list of attributes (positional, structural, or aligned) in a 
corpus.

\paragraph{cqi\_alg2cpos}

From id of region of an alignment attribute to cpos of tokens contained into this 
region.

\paragraph{cqi\_corpus\_info}

Various information about a corpus

\paragraph{cqi\_cpos2alg}

From token cpos to the corresponding region id of an alignment attribute.

\paragraph{cqi\_cpos2id}

From token cpos to the corresponding id in a given positional attribute.

\paragraph{cqi\_cpos2lbound}

?? Given a token cpos, give the left most token cpos bellonging to the same 
region in the given structural attribute.

\paragraph{cqi\_cpos2rbound}

?? Given a token cpos, give the right most token cpos bellonging to the same 
region in the given structural attribute.

\paragraph{cqi\_cpos2str}
\paragraph{cqi\_cpos2struc}
\paragraph{cqi\_drop\_subcorpus}
\paragraph{cqi\_dump\_subcorpus}
\paragraph{cqi\_fdist1}
\paragraph{cqi\_fdist2}
\paragraph{cqi\_full\_name}
\paragraph{cqi\_id2cpos}
\paragraph{cqi\_id2freq}
\paragraph{cqi\_id2str}
\paragraph{cqi\_lexicon\_size}
\paragraph{cqi\_list\_corpora}
\paragraph{cqi\_list\_subcorpora}
\paragraph{cqi\_query}
\paragraph{cqi\_regex2id}
\paragraph{cqi\_str2id}
\paragraph{cqi\_struc2cpos}
\paragraph{cqi\_struc2str}
\paragraph{cqi\_structural\_attribute\_has\_values}
\paragraph{cqi\_subcorpus\_size}

% ----------------------------------------------------------------
% ----------------------------------------------------------------

\section{integrating CQP into R}

A set of high-level functions is aimed at making more easy the use of cqp 
with R and more self-expanatory the data model of CWB.

\subsection{A sample session}
\label{sec:rcqp-session}

<<rcqp_session, echo=TRUE>>=
# create a corpus
c <- corpus("VIE_FR")
c # print all information for a span of tokens (default : 0->20).
print(c, from=200, to=210) # change the default token span.

c <- corpus("DICKENS")
c

# summary give a quick view of the information available in the corpus,
# it does not display actual information:
summary(c)

@

\subsection{Functions}

\label{sec:rcqp-functions}

\subsubsection{S3 object cqp\_corpus}

An object cqp\_corpus is created with the function corpus(). This object 
may be used with the two functions below, as well as for creating 
cqp\_subcorpus, cqp\_filst and cqp\_ftable objects (see bellow).

\paragraph{print.cqp\_corpus}

Print all information (but the value of structural attribute having a 
value) as a data.frame.

\paragraph{summary.cqp\_corpus}

Give the number of tokens of a corpus, list all the attributes 
(positionnal, structural, alignment) ; for each positional attribute (and 
structural attribute having a value) give the number of types and print 
some types.

\subsubsection{S3 object cqp\_subcorpus}

An object cqp\_subcorpus is created with the function subcorpus().

\paragraph{print.cqp\_subcorpus}

Print a given positional attribute (default: word) in a KWIC (key-word in 
context) form.

\paragraph{summary.cqp\_corpus}

\subsubsection{S3 object cqp\_flist}

An object cqp\_flist hold a frequency list and is created with the function 
flist().

A frequency list give the number of tokens for each types of a positional 
attribute.

\paragraph{print.cqp\_corpus}

\paragraph{summary.cqp\_corpus}

\subsubsection{S3 object cqp\_ftable}

An object cqp\_ftable hold a frequency table and is created with the 
functions struct2ftable.cqp\_corpus() or ftable.cqp\_subcorpus().

A frequency table give the number of tokens for each types of a positional 
attribute and for a set of sub-parts of the corpus.

\paragraph{print.cqp\_corpus}

\paragraph{summary.cqp\_corpus}


% ----------------------------------------------------------------
% ----------------------------------------------------------------

\section{ínteractive shell in R}

\subsection{A sample session}
\label{sec:rcqp-session}

<<rcqp_session, echo=TRUE>>=

@

\begin{Schunk}
\begin{Sinput}

\end{Sinput}
\end{Schunk}

\end{document}
